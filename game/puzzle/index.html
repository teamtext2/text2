<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- === SEO META TAGS === -->
    <title>Text2 - Block Puzzle game</title>
    <meta name="description" content="Play Text2 - Block Puzzle, an engaging ice block puzzle game. Beautiful Dark Mode interface with relaxing sounds. Play for free at Text02.">
    <meta name="keywords" content="Text2 - Block Puzzle game, Block Puzzle, puzzle game, block puzzle, ice block puzzle, text02, brain game">
    <meta name="author" content="Text02">
    <link rel="canonical" href="https://text02.com/game/puzzle">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <meta name="google" content="notranslate"> 
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1722731267767270"
    crossorigin="anonymous"></script>
  <!-- Google tag (gtag.js) - GA4 -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-ABCDEFG123"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-6J85STMJ14');
  </script>
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://text02.com/game/puzzle">
    <meta property="og:title" content="Text2 - Block Puzzle game">
    <meta property="og:description" content="Challenge your mind with Text2 - Block Puzzle. Ice block puzzle game with stunning Dark Mode style.">
    <meta property="og:image" content="https://text02.com/media/thumnel.png">
    <meta property="og:site_name" content="Text02">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://text02.com/game/puzzle">
    <meta property="twitter:title" content="Text2 - Block Puzzle game">
    <meta property="twitter:description" content="Challenge your mind with Text2 - Block Puzzle. Ice block puzzle game with stunning Dark Mode style.">
    <meta property="twitter:image" content="https://text02.com/media/thumnel.png">

    <!-- Schema.org Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Text2 - Block Puzzle game",
      "url": "https://text02.com/game/puzzle",
      "image": "https://text02.com/media/thumnel.png",
      "description": "Text2 - Block Puzzle game with modern Dark Mode interface and relaxing ASMR sounds.",
      "applicationCategory": "GameApplication",
      "genre": "Puzzle",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "author": {
        "@type": "Organization",
        "name": "Text02",
        "url": "https://text02.com/"
      }
    }
    </script>
    
    <!-- Tailwind CSS (Utility classes) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Favicon -->
    <link rel="icon" href="https://text02.com/favicon.ico">

    <style>
        /* Custom Styles & Animations */
        body {
            overscroll-behavior: none; /* Prevent pull-to-refresh on mobile */
            -webkit-tap-highlight-color: transparent;
            touch-action: none; /* Disable default touch actions globally */
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes bounceSmall {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        /* Pulse effect with light blue color to match dark theme + ice */
        @keyframes pulseIce {
            0%, 100% { transform: scale(1); color: #bae6fd; }
            50% { transform: scale(1.2); color: #38bdf8; text-shadow: 0 0 15px rgba(56, 189, 248, 0.8); }
        }

        .animate-fade-in { animation: fadeIn 0.3s ease-out; }
        .animate-bounce-small { animation: bounceSmall 0.4s ease-out; }
        .animate-pulse-ice { animation: pulseIce 0.5s ease-in-out; }

        /* Custom Scrollbar for Settings if needed */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="flex flex-col h-screen bg-[#121212] text-white font-sans select-none overflow-hidden">

    <!-- === APP HEADER === -->
    <!-- Gradient Background for Panel: Dark Gray Gradient -->
    <header class="shrink-0 h-16 bg-gradient-to-r from-[#1E1E1E] to-[#242424] flex items-center justify-between px-4 shadow-lg z-20 relative border-b border-white/5">
        <!-- Home Button (Updated Link) -->
        <a href="https://text02.com/" class="w-10 h-10 flex items-center justify-center rounded-full bg-[#242424] text-white shadow-md hover:bg-[#4fc3f7]/20 active:scale-90 transition-all border border-white/5">
            <img src="https://text02.com/favicon.ico" alt="Home" class="w-5 h-5 drop-shadow-sm">
        </a>

        <!-- Center: Score & High Score -->
        <div class="flex flex-col items-center justify-center">
            <div id="score-display" class="text-3xl font-bold text-white leading-none drop-shadow-md font-mono transition-transform">0</div>
            <div class="text-[10px] text-[#c0c0c0] font-bold tracking-wider flex items-center gap-1 mt-1">
                <i data-lucide="trophy" class="w-3 h-3 text-[#c0c0c0]"></i> 
                <span id="highscore-display" class="text-[#c0c0c0]">0</span>
            </div>
        </div>
        
        <!-- Settings Button -->
        <button id="btn-settings" class="w-10 h-10 flex items-center justify-center rounded-full bg-[#242424] text-white shadow-md hover:bg-[#4fc3f7]/20 active:scale-90 transition-all border border-white/5">
            <i data-lucide="settings" class="w-5 h-5 drop-shadow-sm"></i>
        </button>
    </header>

    <!-- === MAIN CONTENT === -->
    <main class="flex-1 relative flex flex-col items-center justify-center w-full overflow-hidden bg-[#121212]">
        <!-- Canvas Container -->
        <div id="canvas-container" class="w-full h-full relative flex items-center justify-center">
            <canvas id="game-canvas" class="block w-full h-full touch-none cursor-grab active:cursor-grabbing"></canvas>
        </div>
    </main>

    <!-- === SETTINGS MODAL === -->
    <div id="modal-settings" class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm px-4 animate-fade-in">
        <div class="bg-gradient-to-b from-[#1E1E1E] to-[#242424] p-6 rounded-2xl shadow-2xl border border-white/10 text-center w-full max-w-sm relative transform scale-100">
            <button id="btn-close-settings" class="absolute top-3 right-3 text-[#c0c0c0] hover:text-white hover:bg-[#4fc3f7]/20 rounded-full p-1 transition-colors">
                <i data-lucide="x" class="w-6 h-6"></i>
            </button>
            
            <h2 class="text-2xl font-bold text-white mb-6 flex items-center justify-center gap-2">
                <i data-lucide="settings" class="w-7 h-7"></i> Settings
            </h2>
            
            <div class="space-y-4">
                <!-- Sound Toggle -->
                <button id="btn-toggle-sound" class="w-full py-3 px-6 font-bold rounded-xl shadow-md flex items-center justify-between transition-all bg-[#242424] hover:bg-[#4fc3f7]/20 text-white border border-white/5 active:scale-95">
                    <span class="flex items-center gap-2">
                        <i id="icon-sound" data-lucide="volume-2" class="w-5 h-5"></i> Sound
                    </span>
                    <span id="text-sound-status" class="text-xs font-bold px-3 py-1 rounded-full bg-[#4caf50] text-white shadow-md">ON</span>
                </button>
                
                <!-- Restart -->
                <button id="btn-restart-settings" class="w-full py-3 px-6 font-bold rounded-xl shadow-md flex items-center justify-center gap-2 transition-all bg-[#ff9800] hover:bg-[#f57c00] active:bg-[#e65100] active:scale-95 text-white shadow-lg">
                    <i data-lucide="refresh-cw" class="w-5 h-5"></i> Restart Game
                </button>
            </div>
        </div>
    </div>

    <!-- === GAME OVER MODAL === -->
    <div id="modal-gameover" class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm px-4 animate-fade-in">
        <div class="bg-gradient-to-b from-[#1E1E1E] to-[#242424] p-6 rounded-2xl shadow-2xl border border-white/10 text-center w-full max-w-sm animate-bounce-small">
            <h2 class="text-3xl font-bold text-white mb-2">Game Over!</h2>
            <p class="text-[#c0c0c0] mb-6">You have no more moves.</p>
            
            <div class="bg-[#121212] p-4 rounded-xl mb-6 shadow-inner border border-white/5">
                <div class="text-sm text-[#c0c0c0] mb-1 uppercase tracking-wider">Your Score</div>
                <div id="final-score" class="text-5xl font-bold text-[#4fc3f7] drop-shadow-[0_0_10px_rgba(79,195,247,0.5)] font-mono">0</div>
            </div>

            <button id="btn-restart-gameover" class="w-full py-3 px-6 font-bold rounded-xl shadow-md flex items-center justify-center gap-2 transition-all bg-[#4caf50] hover:bg-[#43a047] active:bg-[#388e3c] active:scale-95 text-lg text-white shadow-lg">
                <i data-lucide="refresh-cw" class="w-6 h-6"></i> Play Again
            </button>
        </div>
    </div>

    <!-- === GAME LOGIC SCRIPT === -->
    <script>
        // --- NEW CONFIGURATION (DARK UI + ICE BLOCKS) ---
        const GRID_SIZE = 10;
        const COLORS = {
            background: '#121212', // Dark gray (App Background)
            boardBg: '#1E1E1E',    // Dark gray (Board Background)
            trayBg: 'rgba(30, 30, 30, 0.6)', // Dark tray background
            trayBorder: 'rgba(255, 255, 255, 0.08)', // Faded white border
            gridLine: 'rgba(255, 255, 255, 0.05)', // Faded grid line
            cellEmpty: '#242424', // Dark gray empty cell
            
            // Ice Block Colors (Keep ice effect)
            // Ice colors will stand out on dark background
            iceLight: '#bae6fd', 
            iceDark: '#0284c7',  
            
            highlightValid: 'rgba(79, 195, 247, 0.2)', // Light blue (as requested)
            highlightInvalid: 'rgba(239, 68, 68, 0.25)', // Faded red
            floatingText: '#ffffff' // White text stands out
        };

        const SHAPES = [
            { id: '1x1', matrix: [[1]] },
            { id: '1x2', matrix: [[1, 1]] },
            { id: '1x3', matrix: [[1, 1, 1]] },
            { id: '1x4', matrix: [[1, 1, 1, 1]] },
            { id: '1x5', matrix: [[1, 1, 1, 1, 1]] },
            { id: '2x1', matrix: [[1], [1]] },
            { id: '3x1', matrix: [[1], [1], [1]] },
            { id: '4x1', matrix: [[1], [1], [1], [1]] },
            { id: '5x1', matrix: [[1], [1], [1], [1], [1]] },
            { id: '2x2', matrix: [[1, 1], [1, 1]] },
            { id: '3x3', matrix: [[1, 1, 1], [1, 1, 1], [1, 1, 1]] },
            { id: 'L1', matrix: [[1, 0], [1, 0], [1, 1]] },
            { id: 'L2', matrix: [[0, 1], [0, 1], [1, 1]] },
            { id: 'L3', matrix: [[1, 1, 1], [1, 0, 0]] },
            { id: 'L4', matrix: [[1, 1, 1], [0, 0, 1]] },
            { id: 'T1', matrix: [[1, 1, 1], [0, 1, 0]] },
            { id: 'T2', matrix: [[0, 1, 0], [1, 1, 1]] },
            { id: 'Z1', matrix: [[1, 1, 0], [0, 1, 1]] },
            { id: 'Z2', matrix: [[0, 1, 1], [1, 1, 0]] },
        ];

        // --- AUDIO SYSTEM ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let soundEnabled = true;

        const playSound = (type) => {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => {});

            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            const now = audioCtx.currentTime;

            if (type === 'place') {
                // Sound of placing ice block
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'clear') {
                // Sound of ice breaking
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.linearRampToValueAtTime(1200, now + 0.1);
                osc.frequency.linearRampToValueAtTime(600, now + 0.3);
                gainNode.gain.setValueAtTime(0.1, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now);
                osc.stop(now + 0.3);
            } else if (type === 'gameover') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.linearRampToValueAtTime(50, now + 0.8);
                gainNode.gain.setValueAtTime(0.2, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.8);
                osc.start(now);
                osc.stop(now + 0.8);
            } else if (type === 'pickup') {
                osc.type = 'sine';
                osc.frequency.setValueAtTime(500, now);
                osc.frequency.linearRampToValueAtTime(600, now + 0.05);
                gainNode.gain.setValueAtTime(0.05, now);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.05);
                osc.start(now);
                osc.stop(now + 0.05);
            }
        };

        // --- GAME ENGINE ---
        class GameEngine {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d', { alpha: false }); // Optimize rendering
                this.grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
                
                this.blocks = [];
                this.animatingBlocks = []; 
                this.dragBlock = null;
                this.dragPos = { x: 0, y: 0 };
                
                this.score = 0;
                this.particles = [];
                this.floatingTexts = []; 
                
                this.isGameOver = false;
                
                this.trayY = 0;
                this.trayHeight = 0;

                this.resize = this.resize.bind(this);
                this.loop = this.loop.bind(this);

                window.addEventListener('resize', () => setTimeout(this.resize, 100));
                
                setTimeout(() => {
                    this.resize();
                    this.spawnBlocks();
                    this.loop();
                }, 100);
            }

            resize() {
                const parent = this.canvas.parentElement;
                if (parent) {
                    const dpr = window.devicePixelRatio || 1;
                    this.width = parent.clientWidth;
                    this.height = parent.clientHeight;
                    
                    this.canvas.width = this.width * dpr;
                    this.canvas.height = this.height * dpr;
                    this.ctx.scale(dpr, dpr);
                    this.canvas.style.width = `${this.width}px`;
                    this.canvas.style.height = `${this.height}px`;

                    const padding = 16;
                    const availableHeightForBoard = this.height - 200; 
                    const maxBoardWidth = this.width - padding * 2;
                    const boardSize = Math.min(maxBoardWidth, availableHeightForBoard);
                    
                    this.cellSize = Math.floor(boardSize / GRID_SIZE);
                    this.gridOriginX = (this.width - this.cellSize * GRID_SIZE) / 2;
                    this.gridOriginY = 20; 

                    this.updateBlockPositions();
                }
            }

            updateBlockPositions() {
                const trayTopMargin = 20;
                this.trayY = this.gridOriginY + this.cellSize * GRID_SIZE + trayTopMargin;
                this.trayHeight = Math.max(120, this.height - this.trayY - 20); 

                const blockCenterY = this.trayY + this.trayHeight / 2;
                const availableWidth = this.width;
                const slotWidth = availableWidth / 3;

                this.blocks.forEach((block, index) => {
                    if (!block.placed) {
                        const blockW = block.matrix[0].length * this.cellSize * 0.6;
                        const blockH = block.matrix.length * this.cellSize * 0.6;
                        
                        block.homeX = slotWidth * index + slotWidth / 2 - blockW / 2;
                        block.homeY = blockCenterY - blockH / 2;
                        
                        if (block !== this.dragBlock && !this.animatingBlocks.includes(block)) {
                            block.x = block.homeX;
                            block.y = block.homeY;
                            block.scale = 0.6; 
                        }
                    }
                });
            }

            spawnBlocks() {
                this.blocks = [];
                for (let i = 0; i < 3; i++) {
                    const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
                    const matrix = shape.matrix.map(row => [...row]);
                    this.blocks.push({
                        matrix: matrix,
                        id: shape.id,
                        uid: Date.now() + i,
                        placed: false,
                        x: 0, 
                        y: 0,
                        scale: 0.6
                    });
                }
                this.updateBlockPositions();
                this.checkGameOver();
            }

            // --- DRAW ICE BLOCK (Keep ice drawing logic to stand out on dark background) ---
            drawIceTexture(x, y, w, h, filled = false) {
                const ctx = this.ctx;
                
                // Ice Gradient
                const grd = ctx.createLinearGradient(x, y, x + w, y + h);
                if (filled) {
                    // Deep Ice
                    grd.addColorStop(0, '#38bdf8'); // Sky 400
                    grd.addColorStop(1, '#0369a1'); // Sky 700
                } else {
                    // Light Ice
                    grd.addColorStop(0, '#e0f2fe'); // Sky 50
                    grd.addColorStop(1, '#7dd3fc'); // Sky 300
                }
                ctx.fillStyle = grd;
                ctx.fillRect(x, y, w, h);

                // Glass Glint
                ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + w * 0.6, y);
                ctx.lineTo(x, y + h * 0.6);
                ctx.fill();

                // Inner Border (Bevel)
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.beginPath();
                ctx.moveTo(x + w, y);
                ctx.lineTo(x, y);
                ctx.lineTo(x, y + h);
                ctx.stroke();

                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)'; // Darker to match black background
                ctx.beginPath();
                ctx.moveTo(x + w, y);
                ctx.lineTo(x + w, y + h);
                ctx.lineTo(x, y + h);
                ctx.stroke();

                // Outer Border
                ctx.strokeStyle = filled ? 'rgba(12, 74, 110, 0.5)' : 'rgba(56, 189, 248, 0.6)';
                ctx.strokeRect(x, y, w, h);
            }

            drawBlockShape(block, x, y, scale, shadow = false, isPreview = false) {
                const ctx = this.ctx;
                const cellSize = this.cellSize * scale;

                if (shadow) {
                    ctx.shadowColor = "rgba(79, 195, 247, 0.4)"; // Light blue shadow
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetY = 10;
                } else {
                    ctx.shadowColor = "transparent";
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetY = 0;
                }
                
                if (isPreview) {
                     ctx.globalAlpha = 0.6; 
                }

                for (let r = 0; r < block.matrix.length; r++) {
                    for (let c = 0; c < block.matrix[r].length; c++) {
                        if (block.matrix[r][c] === 1) {
                            this.drawIceTexture(x + c * cellSize, y + r * cellSize, cellSize - 1, cellSize - 1, false);
                        }
                    }
                }
                
                ctx.globalAlpha = 1.0;
                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;
            }

            createExplosion(r, c) {
                const x = this.gridOriginX + c * this.cellSize + this.cellSize / 2;
                const y = this.gridOriginY + r * this.cellSize + this.cellSize / 2;
                const colors = ['#ffffff', '#e0f2fe', '#bae6fd', '#7dd3fc'];

                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 1.0,
                        size: Math.random() * 4 + 2,
                        color: colors[Math.floor(Math.random() * colors.length)]
                    });
                }
            }
            
            createFloatingText(text, x, y) {
                this.floatingTexts.push({
                    text: text,
                    x: x,
                    y: y,
                    vy: -1, 
                    alpha: 1.0,
                    life: 40 
                });
            }

            updateAnimations() {
                // 1. Return-to-home animation
                for (let i = this.animatingBlocks.length - 1; i >= 0; i--) {
                    const b = this.animatingBlocks[i];
                    b.x += (b.homeX - b.x) * 0.2;
                    b.y += (b.homeY - b.y) * 0.2;
                    b.scale += (0.6 - b.scale) * 0.2;
                    
                    if (Math.abs(b.x - b.homeX) < 1 && Math.abs(b.y - b.homeY) < 1) {
                        b.x = b.homeX;
                        b.y = b.homeY;
                        b.scale = 0.6;
                        this.animatingBlocks.splice(i, 1); 
                    }
                }

                // 2. Drag Block Scale
                if (this.dragBlock) {
                    this.dragBlock.scale += (1.0 - this.dragBlock.scale) * 0.3;
                }

                // 3. Particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.life -= 0.04;
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.2; // Gravity
                    if (p.life <= 0) this.particles.splice(i, 1);
                }
                
                // 4. Floating Texts
                for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                    const ft = this.floatingTexts[i];
                    ft.y += ft.vy;
                    ft.alpha -= 0.02;
                    if (ft.alpha <= 0) this.floatingTexts.splice(i, 1);
                }
            }

            draw() {
                const ctx = this.ctx;
                
                // Fill background
                ctx.fillStyle = COLORS.background;
                ctx.fillRect(0, 0, this.width, this.height);

                // --- 1. BOARD ---
                ctx.fillStyle = COLORS.boardBg;
                const boardSize = this.cellSize * GRID_SIZE;
                
                // Board Shadow / Glow (Reduce blue glow to match black background)
                ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
                ctx.shadowBlur = 20;
                ctx.shadowOffsetY = 5;
                
                ctx.beginPath();
                if (ctx.roundRect) {
                    ctx.roundRect(this.gridOriginX - 6, this.gridOriginY - 6, boardSize + 12, boardSize + 12, 12);
                } else {
                    ctx.rect(this.gridOriginX - 6, this.gridOriginY - 6, boardSize + 12, boardSize + 12);
                }
                ctx.fill();
                ctx.shadowColor = "transparent";
                ctx.shadowBlur = 0;
                ctx.shadowOffsetY = 0;

                // Cells
                for (let r = 0; r < GRID_SIZE; r++) {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        const cx = this.gridOriginX + c * this.cellSize;
                        const cy = this.gridOriginY + r * this.cellSize;

                        if (this.grid[r][c] === 1) {
                            this.drawIceTexture(cx + 1, cy + 1, this.cellSize - 2, this.cellSize - 2, true);
                        } else {
                            ctx.fillStyle = COLORS.cellEmpty;
                            ctx.fillRect(cx + 1, cy + 1, this.cellSize - 2, this.cellSize - 2);
                        }
                    }
                }

                // --- 2. TRAY (Block container) ---
                if (this.trayHeight > 0) {
                    ctx.fillStyle = COLORS.trayBg;
                    ctx.strokeStyle = COLORS.trayBorder;
                    ctx.lineWidth = 1;
                    
                    const trayW = this.width - 32; 
                    const trayX = 16;
                    
                    ctx.beginPath();
                    if (ctx.roundRect) {
                        ctx.roundRect(trayX, this.trayY, trayW, this.trayHeight, 16);
                    } else {
                        ctx.rect(trayX, this.trayY, trayW, this.trayHeight);
                    }
                    ctx.fill();
                    ctx.stroke();
                }

                // --- 3. PREVIEW (Highlight) ---
                if (this.dragBlock) {
                    const { r, c } = this.getGridPosFromCoords(this.dragPos.x, this.dragPos.y);
                    
                    if (r !== -1 && c !== -1) {
                        const isValid = this.canPlace(this.dragBlock.matrix, r, c);
                        const snapX = this.gridOriginX + c * this.cellSize;
                        const snapY = this.gridOriginY + r * this.cellSize;
                        
                        ctx.fillStyle = isValid ? COLORS.highlightValid : COLORS.highlightInvalid;
                        
                        for (let i = 0; i < this.dragBlock.matrix.length; i++) {
                            for (let j = 0; j < this.dragBlock.matrix[0].length; j++) {
                                if (this.dragBlock.matrix[i][j] === 1) {
                                    ctx.beginPath();
                                    ctx.roundRect(snapX + j * this.cellSize, snapY + i * this.cellSize, this.cellSize, this.cellSize, 4);
                                    ctx.fill();
                                }
                            }
                        }
                    }
                }

                // --- 4. BLOCKS IN TRAY ---
                this.blocks.forEach(block => {
                    if (block !== this.dragBlock) {
                        this.drawBlockShape(block, block.x, block.y, block.scale, true); 
                    }
                });

                // --- 5. DRAGGED BLOCK (ON TOP) ---
                if (this.dragBlock) {
                    const blockPixelW = this.dragBlock.matrix[0].length * this.cellSize * this.dragBlock.scale;
                    const blockPixelH = this.dragBlock.matrix.length * this.cellSize * this.dragBlock.scale;
                    
                    const dragOffsetY = 90; 

                    this.drawBlockShape(
                        this.dragBlock, 
                        this.dragPos.x - blockPixelW / 2, 
                        this.dragPos.y - blockPixelH / 2 - dragOffsetY, 
                        this.dragBlock.scale, 
                        true
                    );
                }

                // --- 6. EFFECTS ---
                this.ctx.globalCompositeOperation = 'lighter'; 
                for (const p of this.particles) {
                    this.ctx.globalAlpha = Math.max(0, p.life);
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                this.ctx.globalCompositeOperation = 'source-over';
                this.ctx.globalAlpha = 1.0;
                
                ctx.font = "bold 24px monospace";
                ctx.textAlign = "center";
                for (const ft of this.floatingTexts) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${ft.alpha})`; // White text stands out on black background
                    ctx.shadowColor = "rgba(0,0,0,0.8)";
                    ctx.shadowBlur = 4;
                    ctx.fillText(ft.text, ft.x, ft.y);
                }
                ctx.shadowBlur = 0;
            }

            getGridPosFromCoords(x, y) {
                if (!this.dragBlock) return { r: -1, c: -1 };
                
                const dragOffsetY = 90;
                const blockPixelW = this.dragBlock.matrix[0].length * this.cellSize;
                const blockPixelH = this.dragBlock.matrix.length * this.cellSize;
                
                const realX = x - blockPixelW / 2;
                const realY = y - blockPixelH / 2 - dragOffsetY;
                
                const relativeX = realX - this.gridOriginX;
                const relativeY = realY - this.gridOriginY;
                
                const c = Math.round(relativeX / this.cellSize);
                const r = Math.round(relativeY / this.cellSize);
                
                return { r, c };
            }

            canPlace(matrix, r, c) {
                if (r < 0 || c < 0) return false;
                const rows = matrix.length;
                const cols = matrix[0].length;
                if (r + rows > GRID_SIZE || c + cols > GRID_SIZE) return false;
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        if (matrix[i][j] === 1 && this.grid[r + i][c + j] === 1) return false;
                    }
                }
                return true;
            }

            placeBlock(block, r, c) {
                const matrix = block.matrix;
                let points = 0;
                
                for (let i = 0; i < matrix.length; i++) {
                    for (let j = 0; j < matrix[0].length; j++) {
                        if (matrix[i][j] === 1) {
                            this.grid[r + i][c + j] = 1;
                            points += 10;
                        }
                    }
                }
                
                playSound('place');
                
                const textX = this.gridOriginX + c * this.cellSize + (matrix[0].length * this.cellSize) / 2;
                const textY = this.gridOriginY + r * this.cellSize;
                this.createFloatingText(`+${points}`, textX, textY);

                this.blocks = this.blocks.filter(b => b !== block);
                
                if (this.blocks.length === 0) this.spawnBlocks();

                const linesCleared = this.checkLines();
                if (linesCleared > 0) {
                    playSound('clear');
                    const bonus = linesCleared * 100 * (linesCleared > 1 ? 1.5 : 1);
                    points += bonus;
                    setTimeout(() => {
                        this.createFloatingText(linesCleared > 1 ? `COMBO +${bonus}` : `+${bonus}`, this.width/2, this.gridOriginY + this.cellSize * 5);
                    }, 200);
                }

                updateScore(this.score + points);
                this.score += points;
                this.checkGameOver();
            }

            checkLines() {
                let linesCleared = 0;
                const rowsToClear = [];
                const colsToClear = [];

                for (let r = 0; r < GRID_SIZE; r++) {
                    if (this.grid[r].every(val => val === 1)) rowsToClear.push(r);
                }
                for (let c = 0; c < GRID_SIZE; c++) {
                    let full = true;
                    for (let r = 0; r < GRID_SIZE; r++) {
                        if (this.grid[r][c] === 0) { full = false; break; }
                    }
                    if (full) colsToClear.push(c);
                }

                rowsToClear.forEach(r => {
                    for (let c = 0; c < GRID_SIZE; c++) {
                        this.grid[r][c] = 0;
                        this.createExplosion(r, c);
                    }
                    linesCleared++;
                });

                colsToClear.forEach(c => {
                    for (let r = 0; r < GRID_SIZE; r++) {
                        this.grid[r][c] = 0;
                        this.createExplosion(r, c);
                    }
                    linesCleared++;
                });

                return linesCleared;
            }

            checkGameOver() {
                if (this.blocks.length === 0) return;
                let canMove = false;
                for (const block of this.blocks) {
                    for (let r = 0; r < GRID_SIZE; r++) {
                        for (let c = 0; c < GRID_SIZE; c++) {
                            if (this.canPlace(block.matrix, r, c)) { canMove = true; break; }
                        }
                        if (canMove) break;
                    }
                    if (canMove) break;
                }

                if (!canMove) {
                    this.isGameOver = true;
                    playSound('gameover');
                    showGameOverModal(this.score);
                }
            }

            restart() {
                this.grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
                this.score = 0;
                this.isGameOver = false;
                this.spawnBlocks();
                updateScore(0);
            }

            loop() {
                this.updateAnimations();
                this.draw();
                requestAnimationFrame(this.loop);
            }

            // Input Handling
            handleDown(x, y) {
                if (this.isGameOver) return;
                const touchRadius = 50; 
                
                for (let i = this.blocks.length - 1; i >= 0; i--) {
                    const b = this.blocks[i];
                    if (this.animatingBlocks.includes(b)) continue;

                    const bw = b.matrix[0].length * this.cellSize * b.scale;
                    const bh = b.matrix.length * this.cellSize * b.scale;
                    const cx = b.x + bw / 2;
                    const cy = b.y + bh / 2;
                    
                    if (Math.abs(x - cx) < bw / 2 + touchRadius && Math.abs(y - cy) < bh / 2 + touchRadius) {
                        this.dragBlock = b;
                        this.dragPos = { x, y };
                        playSound('pickup');
                        break;
                    }
                }
            }

            handleMove(x, y) {
                if (this.dragBlock) this.dragPos = { x, y };
            }

            handleUp() {
                if (this.dragBlock) {
                    const { r, c } = this.getGridPosFromCoords(this.dragPos.x, this.dragPos.y);
                    if (this.canPlace(this.dragBlock.matrix, r, c)) {
                        this.placeBlock(this.dragBlock, r, c);
                    } else {
                        this.animatingBlocks.push(this.dragBlock);
                    }
                    this.dragBlock = null;
                }
            }
        }

        // --- UI LOGIC ---
        const scoreEl = document.getElementById('score-display');
        const highscoreEl = document.getElementById('highscore-display');
        const finalScoreEl = document.getElementById('final-score');
        const modalSettings = document.getElementById('modal-settings');
        const modalGameover = document.getElementById('modal-gameover');
        
        // Buttons
        const btnSettings = document.getElementById('btn-settings');
        const btnCloseSettings = document.getElementById('btn-close-settings');
        const btnToggleSound = document.getElementById('btn-toggle-sound');
        const btnRestartSettings = document.getElementById('btn-restart-settings');
        const btnRestartGameover = document.getElementById('btn-restart-gameover');
        const textSoundStatus = document.getElementById('text-sound-status');
        const iconSound = document.getElementById('icon-sound');

        let highScore = parseInt(localStorage.getItem('woodPuzzleHighScore') || '0');
        highscoreEl.innerText = highScore;

        const canvas = document.getElementById('game-canvas');
        const game = new GameEngine(canvas);

        function updateScore(newScore) {
            scoreEl.innerText = newScore;
            scoreEl.classList.remove('scale-125', 'text-[#4fc3f7]');
            void scoreEl.offsetWidth; // trigger reflow
            scoreEl.classList.add('scale-125', 'text-[#4fc3f7]');
            setTimeout(() => scoreEl.classList.remove('scale-125', 'text-[#4fc3f7]'), 150);

            if (newScore > highScore) {
                highScore = newScore;
                highscoreEl.innerText = highScore;
                highscoreEl.parentElement.classList.add('animate-pulse-ice'); 
                localStorage.setItem('woodPuzzleHighScore', highScore);
            }
        }

        function showGameOverModal(finalScore) {
            finalScoreEl.innerText = finalScore;
            modalGameover.classList.remove('hidden');
        }

        function hideModals() {
            modalSettings.classList.add('hidden');
            modalGameover.classList.add('hidden');
        }

        btnSettings.addEventListener('click', () => {
            modalSettings.classList.remove('hidden');
        });

        btnCloseSettings.addEventListener('click', hideModals);
        
        modalSettings.addEventListener('click', (e) => {
            if (e.target === modalSettings) hideModals();
        });

        btnToggleSound.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            textSoundStatus.innerText = soundEnabled ? 'ON' : 'OFF';
            textSoundStatus.className = `text-xs font-bold px-3 py-1 rounded-full text-white ${soundEnabled ? 'bg-[#4caf50] shadow-md' : 'bg-[#555]'} transition-colors`;
            iconSound.setAttribute('data-lucide', soundEnabled ? 'volume-2' : 'volume-x');
            lucide.createIcons();
        });

        const restartAction = () => {
            game.restart();
            hideModals();
            highscoreEl.parentElement.classList.remove('animate-pulse-ice');
        };

        btnRestartSettings.addEventListener('click', restartAction);
        btnRestartGameover.addEventListener('click', restartAction);

        const getPos = (e) => {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { 
                x: clientX - rect.left, 
                y: clientY - rect.top 
            };
        };

        canvas.addEventListener('mousedown', e => {
            const { x, y } = getPos(e);
            game.handleDown(x, y);
        });
        window.addEventListener('mousemove', e => {
            const { x, y } = getPos(e);
            game.handleMove(x, y);
        });
        window.addEventListener('mouseup', () => game.handleUp());
        
        canvas.addEventListener('touchstart', e => {
            e.preventDefault();
            const { x, y } = getPos(e);
            game.handleDown(x, y);
        }, { passive: false });
        
        window.addEventListener('touchmove', e => {
            if (game.dragBlock) e.preventDefault();
            const { x, y } = getPos(e);
            game.handleMove(x, y);
        }, { passive: false });
        
        window.addEventListener('touchend', () => game.handleUp());

        lucide.createIcons();

    </script>
</body>
</html>